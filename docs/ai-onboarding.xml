This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
CLAUDE.md
Dockerfile
example-usage.sh
index.ts
INSTALL.md
package.json
README.md
test-commands.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Data files
*.json
!package.json
!tsconfig.json
!package-lock.json

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Environment
.env
.env.local

# Temporary files
*.tmp
*.swp
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Task Manager MCP (Model Context Protocol) Server that provides hierarchical project management capabilities to AI assistants. It manages three levels of data: PRDs (Product Requirements Documents) → Epics → Tasks.

## Build and Development Commands

```bash
# Install dependencies
npm install

# Build TypeScript to JavaScript
npm run build

# Watch mode for development
npm run watch

# Run development server with auto-reload
npm run dev

# Run the server directly
node dist/index.js

# Docker build
docker build -t mcp/task-manager .

# Docker run with persistent volume
docker run -i -v task-manager-data:/app/data mcp/task-manager
```

## Architecture

### Data Flow
1. **Storage**: All data persists in a single JSON Lines file (default: `tasks.json`, configurable via `TASK_FILE_PATH` env var)
2. **Data Model**: Each line contains a typed object (`type: 'prd' | 'epic' | 'task'`) with the entity data
3. **Operations**: All operations load the entire dataset, modify in-memory, then write back atomically
4. **IDs**: Generated using timestamp + random suffix pattern: `${prefix}_${timestamp}_${random}`

### Key Architectural Decisions
- **Single File Storage**: Chosen for simplicity and atomic operations over a database
- **JSON Lines Format**: Enables append operations and line-by-line parsing
- **Cascading Deletes**: Deleting a PRD removes all child epics and tasks; deleting an epic removes all child tasks
- **Bulk Operations**: `create_epics` and `create_tasks` accept arrays to reduce round trips

### MCP Server Implementation
- Uses `StdioServerTransport` for communication with Claude Desktop
- All tools return JSON-formatted responses
- Error handling throws descriptive errors that are caught by the MCP framework

## Testing the Server

For manual testing without Claude Desktop:

```bash
# The server expects MCP protocol messages on stdin, so direct execution will wait for input
node dist/index.js

# To test in Claude Desktop, add to claude_desktop_config.json:
# {
#   "mcpServers": {
#     "task-manager": {
#       "command": "node",
#       "args": ["/absolute/path/to/dist/index.js"]
#     }
#   }
# }
```

## Data Schema

### Storage Format
```jsonl
{"type":"prd","id":"prd_xxx","title":"...","description":"...","status":"draft","owner":"...","created_at":"...","updated_at":"..."}
{"type":"epic","id":"epic_xxx","prd_id":"prd_xxx","title":"...","description":"...","status":"not_started","priority":"high","created_at":"..."}
{"type":"task","id":"task_xxx","epic_id":"epic_xxx","title":"...","description":"...","status":"todo","priority":"medium","assignee":"...","due_date":"...","dependencies":[],"notes":[],"created_at":"...","updated_at":"..."}
```

### Status Transitions
- PRD: `draft` → `approved` → `in_progress` → `completed`
- Epic: `not_started` → `in_progress` → `completed`
- Task: `todo` → `in_progress` → `review` → `done`

## Common Development Tasks

### Adding a New Tool
1. Add tool definition in `server.setRequestHandler(ListToolsRequestSchema, ...)`
2. Add case handler in `server.setRequestHandler(CallToolRequestSchema, ...)`
3. Add corresponding method in `TaskManager` class
4. Update type definitions if needed

### Modifying Data Structure
1. Update interface definitions (PRD, Epic, Task)
2. Update the DataItem discriminated union type
3. Modify `loadData()` parsing logic if needed
4. Update `saveData()` serialization
5. Consider migration strategy for existing data files

### Environment Variables
- `TASK_FILE_PATH`: Absolute or relative path to data file (default: `./tasks.json`)
- `NODE_ENV`: Set to `production` in Docker image

## Deployment Considerations

The server is designed to run as a subprocess of Claude Desktop. Key considerations:
- Must handle stdio transport (not HTTP)
- Data file permissions must allow read/write
- ID generation must be unique even with concurrent instances (timestamp + random)
- All operations are synchronous to prevent race conditions
</file>

<file path="Dockerfile">
FROM node:22.12-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install all dependencies for building
RUN npm ci

# Copy source code
COPY index.ts ./

# Build the TypeScript code
RUN npm run build

# Install only production dependencies
RUN npm ci --omit=dev

FROM node:22-alpine AS release

WORKDIR /app

# Copy built files and production dependencies
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

# Create data directory
RUN mkdir -p /app/data

# Set environment variable for data persistence
ENV TASK_FILE_PATH=/app/data/tasks.json
ENV NODE_ENV=production

ENTRYPOINT ["node", "dist/index.js"]
</file>

<file path="example-usage.sh">
#!/bin/bash

# Example usage script for Task Manager MCP Server

echo "Task Manager MCP Server - Example Usage"
echo "======================================="
echo ""
echo "1. Install dependencies:"
echo "   npm install"
echo ""
echo "2. Build the project:"
echo "   npm run build"
echo ""
echo "3. Run the server locally:"
echo "   node dist/index.js"
echo ""
echo "4. Configure in Claude Desktop:"
echo "   Add the following to your claude_desktop_config.json:"
echo ""
echo '   {
     "mcpServers": {
       "task-manager": {
         "command": "node",
         "args": ["/projects/project-manager-mcp/dist/index.js"]
       }
     }
   }'
echo ""
echo "5. Example workflow:"
echo "   - Create a PRD using create_prd"
echo "   - Create epics for the PRD using create_epics"
echo "   - Break down epics into tasks using create_tasks"
echo "   - Update task status as work progresses"
echo "   - Add notes to track progress"
echo ""
echo "For Docker deployment:"
echo "   docker build -t mcp/task-manager ."
echo "   docker run -i -v task-data:/app/data mcp/task-manager"
</file>

<file path="index.ts">
#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Define data file path using environment variable with fallback
const defaultDataPath = path.join(path.dirname(fileURLToPath(import.meta.url)), 'tasks.json');
const TASK_FILE_PATH = process.env.TASK_FILE_PATH
  ? path.isAbsolute(process.env.TASK_FILE_PATH)
    ? process.env.TASK_FILE_PATH
    : path.join(path.dirname(fileURLToPath(import.meta.url)), process.env.TASK_FILE_PATH)
  : defaultDataPath;

// Data structures
interface PRD {
  id: string;
  title: string;
  description: string;
  status: 'draft' | 'approved' | 'in_progress' | 'completed';
  owner: string;
  created_at: string;
  updated_at: string;
}

interface Epic {
  id: string;
  prd_id: string;
  title: string;
  description: string;
  status: 'not_started' | 'in_progress' | 'completed';
  priority: 'low' | 'medium' | 'high';
  created_at: string;
}

interface Task {
  id: string;
  epic_id: string;
  title: string;
  description: string;
  status: 'todo' | 'in_progress' | 'review' | 'done';
  priority: 'low' | 'medium' | 'high';
  assignee?: string;
  due_date?: string;
  dependencies: string[];
  notes: string[];
  created_at: string;
  updated_at: string;
}

type DataItem = 
  | { type: 'prd' } & PRD
  | { type: 'epic' } & Epic
  | { type: 'task' } & Task;

interface ProjectData {
  prds: PRD[];
  epics: Epic[];
  tasks: Task[];
}

// Task Manager class
class TaskManager {
  private async loadData(): Promise<ProjectData> {
    try {
      const data = await fs.readFile(TASK_FILE_PATH, "utf-8");
      const lines = data.split("\n").filter(line => line.trim() !== "");
      return lines.reduce((acc: ProjectData, line) => {
        const item = JSON.parse(line) as DataItem;
        if (item.type === "prd") {
          const { type, ...prd } = item;
          acc.prds.push(prd);
        } else if (item.type === "epic") {
          const { type, ...epic } = item;
          acc.epics.push(epic);
        } else if (item.type === "task") {
          const { type, ...task } = item;
          acc.tasks.push(task);
        }
        return acc;
      }, { prds: [], epics: [], tasks: [] });
    } catch (error) {
      if (error instanceof Error && 'code' in error && (error as any).code === "ENOENT") {
        return { prds: [], epics: [], tasks: [] };
      }
      throw error;
    }
  }

  private async saveData(data: ProjectData): Promise<void> {
    const lines = [
      ...data.prds.map(p => JSON.stringify({ type: "prd", ...p })),
      ...data.epics.map(e => JSON.stringify({ type: "epic", ...e })),
      ...data.tasks.map(t => JSON.stringify({ type: "task", ...t })),
    ];
    await fs.writeFile(TASK_FILE_PATH, lines.join("\n"));
  }

  private generateId(prefix: string): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 5);
    return `${prefix}_${timestamp}_${random}`;
  }

  async createPRD(title: string, description: string, owner: string): Promise<PRD> {
    const data = await this.loadData();
    const now = new Date().toISOString();
    const prd: PRD = {
      id: this.generateId('prd'),
      title,
      description,
      status: 'draft',
      owner,
      created_at: now,
      updated_at: now,
    };
    data.prds.push(prd);
    await this.saveData(data);
    return prd;
  }

  async updatePRD(id: string, updates: Partial<Omit<PRD, 'id' | 'created_at'>>): Promise<PRD> {
    const data = await this.loadData();
    const prdIndex = data.prds.findIndex(p => p.id === id);
    if (prdIndex === -1) {
      throw new Error(`PRD with id ${id} not found`);
    }
    
    data.prds[prdIndex] = {
      ...data.prds[prdIndex],
      ...updates,
      updated_at: new Date().toISOString(),
    };
    
    await this.saveData(data);
    return data.prds[prdIndex];
  }

  async deletePRD(id: string): Promise<void> {
    const data = await this.loadData();
    
    // Find all epics for this PRD
    const epicIds = data.epics.filter(e => e.prd_id === id).map(e => e.id);
    
    // Delete all tasks for those epics
    data.tasks = data.tasks.filter(t => !epicIds.includes(t.epic_id));
    
    // Delete all epics for this PRD
    data.epics = data.epics.filter(e => e.prd_id !== id);
    
    // Delete the PRD
    data.prds = data.prds.filter(p => p.id !== id);
    
    await this.saveData(data);
  }

  async createEpics(epics: Array<{
    prd_id: string;
    title: string;
    description: string;
    priority: 'low' | 'medium' | 'high';
  }>): Promise<Epic[]> {
    const data = await this.loadData();
    const now = new Date().toISOString();
    
    const newEpics = epics.map(e => ({
      id: this.generateId('epic'),
      ...e,
      status: 'not_started' as const,
      created_at: now,
    }));
    
    data.epics.push(...newEpics);
    await this.saveData(data);
    return newEpics;
  }

  async updateEpic(id: string, updates: Partial<Omit<Epic, 'id' | 'prd_id' | 'created_at'>>): Promise<Epic> {
    const data = await this.loadData();
    const epicIndex = data.epics.findIndex(e => e.id === id);
    if (epicIndex === -1) {
      throw new Error(`Epic with id ${id} not found`);
    }
    
    data.epics[epicIndex] = {
      ...data.epics[epicIndex],
      ...updates,
    };
    
    await this.saveData(data);
    return data.epics[epicIndex];
  }

  async deleteEpics(ids: string[]): Promise<void> {
    const data = await this.loadData();
    
    // Delete all tasks for these epics
    data.tasks = data.tasks.filter(t => !ids.includes(t.epic_id));
    
    // Delete the epics
    data.epics = data.epics.filter(e => !ids.includes(e.id));
    
    await this.saveData(data);
  }

  async createTasks(tasks: Array<{
    epic_id: string;
    title: string;
    description: string;
    priority: 'low' | 'medium' | 'high';
    assignee?: string;
    due_date?: string;
    dependencies?: string[];
  }>): Promise<Task[]> {
    const data = await this.loadData();
    const now = new Date().toISOString();
    
    const newTasks = tasks.map(t => ({
      id: this.generateId('task'),
      status: 'todo' as const,
      dependencies: [],
      notes: [],
      ...t,
      created_at: now,
      updated_at: now,
    }));
    
    data.tasks.push(...newTasks);
    await this.saveData(data);
    return newTasks;
  }

  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'epic_id' | 'created_at'>>): Promise<Task> {
    const data = await this.loadData();
    const taskIndex = data.tasks.findIndex(t => t.id === id);
    if (taskIndex === -1) {
      throw new Error(`Task with id ${id} not found`);
    }
    
    data.tasks[taskIndex] = {
      ...data.tasks[taskIndex],
      ...updates,
      updated_at: new Date().toISOString(),
    };
    
    await this.saveData(data);
    return data.tasks[taskIndex];
  }

  async addTaskNotes(taskId: string, notes: string[]): Promise<Task> {
    const data = await this.loadData();
    const taskIndex = data.tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) {
      throw new Error(`Task with id ${taskId} not found`);
    }
    
    data.tasks[taskIndex].notes.push(...notes);
    data.tasks[taskIndex].updated_at = new Date().toISOString();
    
    await this.saveData(data);
    return data.tasks[taskIndex];
  }

  async deleteTasks(ids: string[]): Promise<void> {
    const data = await this.loadData();
    data.tasks = data.tasks.filter(t => !ids.includes(t.id));
    await this.saveData(data);
  }

  async readProject(prdId?: string): Promise<any> {
    const data = await this.loadData();
    
    if (prdId) {
      const prd = data.prds.find(p => p.id === prdId);
      if (!prd) {
        throw new Error(`PRD with id ${prdId} not found`);
      }
      
      const epics = data.epics.filter(e => e.prd_id === prdId);
      const epicIds = epics.map(e => e.id);
      const tasks = data.tasks.filter(t => epicIds.includes(t.epic_id));
      
      return {
        ...prd,
        epics: epics.map(epic => ({
          ...epic,
          tasks: tasks.filter(t => t.epic_id === epic.id),
        })),
      };
    }
    
    // Return all projects
    return data.prds.map(prd => {
      const epics = data.epics.filter(e => e.prd_id === prd.id);
      const epicIds = epics.map(e => e.id);
      const tasks = data.tasks.filter(t => epicIds.includes(t.epic_id));
      
      return {
        ...prd,
        epics: epics.map(epic => ({
          ...epic,
          tasks: tasks.filter(t => t.epic_id === epic.id),
        })),
      };
    });
  }

  async searchItems(query: string, itemType?: 'prd' | 'epic' | 'task'): Promise<any> {
    const data = await this.loadData();
    const lowerQuery = query.toLowerCase();
    
    const results: any = {};
    
    if (!itemType || itemType === 'prd') {
      results.prds = data.prds.filter(p =>
        p.title.toLowerCase().includes(lowerQuery) ||
        p.description.toLowerCase().includes(lowerQuery) ||
        p.owner.toLowerCase().includes(lowerQuery)
      );
    }
    
    if (!itemType || itemType === 'epic') {
      results.epics = data.epics.filter(e =>
        e.title.toLowerCase().includes(lowerQuery) ||
        e.description.toLowerCase().includes(lowerQuery)
      );
    }
    
    if (!itemType || itemType === 'task') {
      results.tasks = data.tasks.filter(t =>
        t.title.toLowerCase().includes(lowerQuery) ||
        t.description.toLowerCase().includes(lowerQuery) ||
        (t.assignee && t.assignee.toLowerCase().includes(lowerQuery)) ||
        t.notes.some(n => n.toLowerCase().includes(lowerQuery))
      );
    }
    
    return results;
  }

  async getTasksByStatus(
    status: Task['status'],
    epicId?: string,
    assignee?: string
  ): Promise<Task[]> {
    const data = await this.loadData();
    
    return data.tasks.filter(t => {
      if (t.status !== status) return false;
      if (epicId && t.epic_id !== epicId) return false;
      if (assignee && t.assignee !== assignee) return false;
      return true;
    });
  }

  async getTasksByAssignee(assignee: string): Promise<Task[]> {
    const data = await this.loadData();
    return data.tasks.filter(t => t.assignee === assignee);
  }
}

const taskManager = new TaskManager();

// MCP Server setup
const server = new Server({
  name: "task-manager",
  version: "0.1.0",
}, {
  capabilities: {
    tools: {},
  },
});

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "create_prd",
        description: "Create a new Product Requirements Document",
        inputSchema: {
          type: "object",
          properties: {
            title: { type: "string", description: "Title of the PRD" },
            description: { type: "string", description: "Detailed description of the product requirements" },
            owner: { type: "string", description: "Owner of the PRD" },
          },
          required: ["title", "description", "owner"],
        },
      },
      {
        name: "update_prd",
        description: "Update an existing PRD",
        inputSchema: {
          type: "object",
          properties: {
            id: { type: "string", description: "ID of the PRD to update" },
            title: { type: "string", description: "New title" },
            description: { type: "string", description: "New description" },
            status: { 
              type: "string", 
              enum: ["draft", "approved", "in_progress", "completed"],
              description: "New status" 
            },
            owner: { type: "string", description: "New owner" },
          },
          required: ["id"],
        },
      },
      {
        name: "delete_prd",
        description: "Delete a PRD and all its associated epics and tasks",
        inputSchema: {
          type: "object",
          properties: {
            id: { type: "string", description: "ID of the PRD to delete" },
          },
          required: ["id"],
        },
      },
      {
        name: "create_epics",
        description: "Create multiple epics linked to a PRD",
        inputSchema: {
          type: "object",
          properties: {
            epics: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  prd_id: { type: "string", description: "ID of the parent PRD" },
                  title: { type: "string", description: "Epic title" },
                  description: { type: "string", description: "Epic description" },
                  priority: { 
                    type: "string", 
                    enum: ["low", "medium", "high"],
                    description: "Priority level" 
                  },
                },
                required: ["prd_id", "title", "description", "priority"],
              },
            },
          },
          required: ["epics"],
        },
      },
      {
        name: "update_epic",
        description: "Update an existing epic",
        inputSchema: {
          type: "object",
          properties: {
            id: { type: "string", description: "ID of the epic to update" },
            title: { type: "string", description: "New title" },
            description: { type: "string", description: "New description" },
            status: {
              type: "string",
              enum: ["not_started", "in_progress", "completed"],
              description: "New status"
            },
            priority: {
              type: "string",
              enum: ["low", "medium", "high"],
              description: "New priority"
            },
          },
          required: ["id"],
        },
      },
      {
        name: "delete_epics",
        description: "Delete epics and their associated tasks",
        inputSchema: {
          type: "object",
          properties: {
            ids: {
              type: "array",
              items: { type: "string" },
              description: "IDs of epics to delete"
            },
          },
          required: ["ids"],
        },
      },
      {
        name: "create_tasks",
        description: "Create multiple tasks linked to epics",
        inputSchema: {
          type: "object",
          properties: {
            tasks: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  epic_id: { type: "string", description: "ID of the parent epic" },
                  title: { type: "string", description: "Task title" },
                  description: { type: "string", description: "Task description" },
                  priority: {
                    type: "string",
                    enum: ["low", "medium", "high"],
                    description: "Priority level"
                  },
                  assignee: { type: "string", description: "Person assigned to the task" },
                  due_date: { type: "string", description: "Due date in ISO format" },
                  dependencies: {
                    type: "array",
                    items: { type: "string" },
                    description: "IDs of tasks this depends on"
                  },
                },
                required: ["epic_id", "title", "description", "priority"],
              },
            },
          },
          required: ["tasks"],
        },
      },
      {
        name: "update_task",
        description: "Update an existing task",
        inputSchema: {
          type: "object",
          properties: {
            id: { type: "string", description: "ID of the task to update" },
            title: { type: "string", description: "New title" },
            description: { type: "string", description: "New description" },
            status: {
              type: "string",
              enum: ["todo", "in_progress", "review", "done"],
              description: "New status"
            },
            priority: {
              type: "string",
              enum: ["low", "medium", "high"],
              description: "New priority"
            },
            assignee: { type: "string", description: "New assignee" },
            due_date: { type: "string", description: "New due date in ISO format" },
            dependencies: {
              type: "array",
              items: { type: "string" },
              description: "Updated dependency task IDs"
            },
          },
          required: ["id"],
        },
      },
      {
        name: "add_task_notes",
        description: "Add progress notes to a task",
        inputSchema: {
          type: "object",
          properties: {
            task_id: { type: "string", description: "ID of the task" },
            notes: {
              type: "array",
              items: { type: "string" },
              description: "Notes to add"
            },
          },
          required: ["task_id", "notes"],
        },
      },
      {
        name: "delete_tasks",
        description: "Delete multiple tasks",
        inputSchema: {
          type: "object",
          properties: {
            ids: {
              type: "array",
              items: { type: "string" },
              description: "IDs of tasks to delete"
            },
          },
          required: ["ids"],
        },
      },
      {
        name: "read_project",
        description: "Read project hierarchy (PRD with nested epics and tasks)",
        inputSchema: {
          type: "object",
          properties: {
            prd_id: { type: "string", description: "Optional PRD ID to read specific project" },
          },
        },
      },
      {
        name: "search_items",
        description: "Search across PRDs, epics, and tasks",
        inputSchema: {
          type: "object",
          properties: {
            query: { type: "string", description: "Search query" },
            item_type: {
              type: "string",
              enum: ["prd", "epic", "task"],
              description: "Optional filter by item type"
            },
          },
          required: ["query"],
        },
      },
      {
        name: "get_tasks_by_status",
        description: "Get tasks filtered by status",
        inputSchema: {
          type: "object",
          properties: {
            status: {
              type: "string",
              enum: ["todo", "in_progress", "review", "done"],
              description: "Task status to filter by"
            },
            epic_id: { type: "string", description: "Optional epic ID filter" },
            assignee: { type: "string", description: "Optional assignee filter" },
          },
          required: ["status"],
        },
      },
      {
        name: "get_tasks_by_assignee",
        description: "Get all tasks assigned to a specific person",
        inputSchema: {
          type: "object",
          properties: {
            assignee: { type: "string", description: "Assignee name" },
          },
          required: ["assignee"],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (!args) {
    throw new Error(`No arguments provided for tool: ${name}`);
  }

  switch (name) {
    case "create_prd":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.createPRD(
            args.title as string,
            args.description as string,
            args.owner as string
          ), null, 2) 
        }] 
      };

    case "update_prd":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.updatePRD(
            args.id as string,
            args as any
          ), null, 2) 
        }] 
      };

    case "delete_prd":
      await taskManager.deletePRD(args.id as string);
      return { content: [{ type: "text", text: "PRD and all associated items deleted successfully" }] };

    case "create_epics":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.createEpics(args.epics as any[]), null, 2) 
        }] 
      };

    case "update_epic":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.updateEpic(
            args.id as string,
            args as any
          ), null, 2) 
        }] 
      };

    case "delete_epics":
      await taskManager.deleteEpics(args.ids as string[]);
      return { content: [{ type: "text", text: "Epics and associated tasks deleted successfully" }] };

    case "create_tasks":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.createTasks(args.tasks as any[]), null, 2) 
        }] 
      };

    case "update_task":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.updateTask(
            args.id as string,
            args as any
          ), null, 2) 
        }] 
      };

    case "add_task_notes":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.addTaskNotes(
            args.task_id as string,
            args.notes as string[]
          ), null, 2) 
        }] 
      };

    case "delete_tasks":
      await taskManager.deleteTasks(args.ids as string[]);
      return { content: [{ type: "text", text: "Tasks deleted successfully" }] };

    case "read_project":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.readProject(args.prd_id as string), null, 2) 
        }] 
      };

    case "search_items":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.searchItems(
            args.query as string,
            args.item_type as any
          ), null, 2) 
        }] 
      };

    case "get_tasks_by_status":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.getTasksByStatus(
            args.status as any,
            args.epic_id as string,
            args.assignee as string
          ), null, 2) 
        }] 
      };

    case "get_tasks_by_assignee":
      return { 
        content: [{ 
          type: "text", 
          text: JSON.stringify(await taskManager.getTasksByAssignee(
            args.assignee as string
          ), null, 2) 
        }] 
      };

    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Task Manager MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});
</file>

<file path="INSTALL.md">
# Quick Installation Guide

## Local Development Setup

1. Navigate to the project directory:
```bash
cd /projects/project-manager-mcp
```

2. Install dependencies:
```bash
npm install
```

3. Build the TypeScript code:
```bash
npm run build
```

4. Test the server (optional):
```bash
node dist/index.js
```
(Press Ctrl+C to stop)

## Configure Claude Desktop

1. Find your Claude Desktop configuration file:
   - macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - Windows: `%APPDATA%\Claude\claude_desktop_config.json`
   - Linux: `~/.config/claude/claude_desktop_config.json`

2. Add the task-manager server configuration:
```json
{
  "mcpServers": {
    "task-manager": {
      "command": "node",
      "args": ["/projects/project-manager-mcp/dist/index.js"]
    }
  }
}
```

3. Restart Claude Desktop

## Docker Setup (Optional)

1. Build the Docker image:
```bash
docker build -t mcp/task-manager .
```

2. Update Claude Desktop config for Docker:
```json
{
  "mcpServers": {
    "task-manager": {
      "command": "docker",
      "args": ["run", "-i", "-v", "task-manager-data:/app/data", "--rm", "mcp/task-manager"]
    }
  }
}
```

## Verify Installation

After restarting Claude Desktop, you should see "task-manager" in the MCP tools menu.
Try creating a PRD to test the connection!
</file>

<file path="package.json">
{
  "name": "@modelcontextprotocol/server-task-manager",
  "version": "0.1.0",
  "description": "MCP server for managing PRDs, Epics, and Tasks in a hierarchical project structure",
  "license": "MIT",
  "author": "Your Name",
  "homepage": "https://github.com/yourusername/task-manager-mcp",
  "bugs": "https://github.com/yourusername/task-manager-mcp/issues",
  "type": "module",
  "bin": {
    "mcp-server-task-manager": "dist/index.js"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsc && shx chmod +x dist/*.js",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "dev": "node --watch dist/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "1.0.1"
  },
  "devDependencies": {
    "@types/node": "^22",
    "shx": "^0.3.4",
    "typescript": "^5.6.2"
  }
}
</file>

<file path="README.md">
# Task Manager MCP Server

A Model Context Protocol server for managing Product Requirements Documents (PRDs), Epics, and Tasks in a hierarchical structure. This enables LLMs to create, track, and manage software development projects.

## Core Concepts

### PRDs (Product Requirements Documents)
Top-level documents that define product features and requirements.
- Unique ID
- Title and description
- Status (draft, approved, in_progress, completed)
- Owner
- Creation and update timestamps

Example:
```json
{
  "id": "prd_001",
  "title": "User Authentication System",
  "description": "Implement secure user authentication...",
  "status": "approved",
  "owner": "john_doe",
  "created_at": "2025-01-15T10:00:00Z",
  "updated_at": "2025-01-15T10:00:00Z"
}
```

### Epics
Major features or components that implement parts of a PRD.
- Unique ID
- Linked to a PRD
- Title and description
- Status and priority
- Creation timestamp

Example:
```json
{
  "id": "epic_001",
  "prd_id": "prd_001",
  "title": "OAuth2 Integration",
  "description": "Implement OAuth2 for third-party login",
  "status": "in_progress",
  "priority": "high",
  "created_at": "2025-01-16T10:00:00Z"
}
```

### Tasks
Specific work items that implement parts of an epic.
- Unique ID
- Linked to an epic
- Title and description
- Status, priority, assignee
- Optional due date and dependencies
- Notes for progress tracking

Example:
```json
{
  "id": "task_001",
  "epic_id": "epic_001",
  "title": "Setup OAuth2 provider configuration",
  "description": "Configure Google and GitHub OAuth providers",
  "status": "in_progress",
  "priority": "high",
  "assignee": "jane_smith",
  "due_date": "2025-01-20T00:00:00Z",
  "dependencies": [],
  "notes": ["Completed Google setup", "GitHub pending approval"],
  "created_at": "2025-01-17T10:00:00Z",
  "updated_at": "2025-01-18T14:30:00Z"
}
```

## API Tools

### PRD Management
- **create_prd**
  - Create a new Product Requirements Document
  - Input: `title`, `description`, `owner`
  - Returns: Created PRD with generated ID

- **update_prd**
  - Update an existing PRD
  - Input: `id`, optional `title`, `description`, `status`, `owner`
  - Returns: Updated PRD

- **delete_prd**
  - Delete a PRD and all associated epics and tasks
  - Input: `id`
  - Cascading deletion

### Epic Management
- **create_epics**
  - Create multiple epics linked to a PRD
  - Input: `epics` array with `prd_id`, `title`, `description`, `priority`
  - Returns: Created epics with generated IDs

- **update_epic**
  - Update an existing epic
  - Input: `id`, optional fields to update
  - Returns: Updated epic

- **delete_epics**
  - Delete epics and their associated tasks
  - Input: `ids` array
  - Cascading deletion

### Task Management
- **create_tasks**
  - Create multiple tasks linked to epics
  - Input: `tasks` array with task details
  - Returns: Created tasks with generated IDs

- **update_task**
  - Update task details, status, or assignee
  - Input: `id`, optional fields to update
  - Returns: Updated task

- **add_task_notes**
  - Add progress notes to tasks
  - Input: `task_id`, `notes` array
  - Returns: Updated task

- **delete_tasks**
  - Delete multiple tasks
  - Input: `ids` array

### Query Tools
- **read_project**
  - Read entire project hierarchy
  - Input: `prd_id` (optional)
  - Returns: PRDs with nested epics and tasks

- **search_items**
  - Search across PRDs, epics, and tasks
  - Input: `query`, `item_type` (optional filter)
  - Returns: Matching items

- **get_tasks_by_status**
  - Get tasks filtered by status
  - Input: `status`, optional `epic_id`, `assignee`
  - Returns: Filtered tasks

- **get_tasks_by_assignee**
  - Get all tasks for a specific assignee
  - Input: `assignee`
  - Returns: Assigned tasks

## Usage with Claude Desktop

Add this to your claude_desktop_config.json:

### NPX
```json
{
  "mcpServers": {
    "task-manager": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-task-manager"
      ]
    }
  }
}
```

### Docker
```json
{
  "mcpServers": {
    "task-manager": {
      "command": "docker",
      "args": ["run", "-i", "-v", "task-manager-data:/app/data", "--rm", "mcp/task-manager"]
    }
  }
}
```

### Custom Storage Path
```json
{
  "mcpServers": {
    "task-manager": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-task-manager"
      ],
      "env": {
        "TASK_FILE_PATH": "/path/to/custom/tasks.json"
      }
    }
  }
}
```

## System Prompts for Different LLMs

### PRD Creation LLM
```
You are a product requirements specialist. When asked to create a PRD:
1. Use create_prd to establish the main document
2. Include clear success criteria and user stories
3. Reference existing PRDs using search_items to maintain consistency
4. Set appropriate status (usually "draft" initially)
```

### Task Breakdown LLM
```
You are a project planning specialist. When given a PRD:
1. Use read_project to understand the full PRD
2. Create epics using create_epics for major feature areas
3. Break down each epic into specific tasks using create_tasks
4. Ensure tasks are atomic and have clear acceptance criteria
5. Set appropriate priorities and dependencies
```

### Task Execution LLM
```
You are a development assistant. For task management:
1. Use get_tasks_by_assignee to see assigned work
2. Update task status as work progresses using update_task
3. Add implementation notes using add_task_notes
4. Check dependencies before starting tasks
5. Search for related tasks to understand context
```

## Data Persistence

The server stores all data in a single JSON lines file where each line represents a PRD, Epic, or Task. This allows for:
- Simple backup and restore
- Easy debugging and manual inspection
- Atomic writes for data integrity
- Efficient append operations

## Building

```sh
cd /projects/project-manager-mcp
npm install
npm run build
```

Docker:
```sh
docker build -t mcp/task-manager .
```

## License

This MCP server is licensed under the MIT License.
</file>

<file path="test-commands.md">
# Task Manager MCP Server - Test Script

This script demonstrates basic usage of the Task Manager MCP Server.

## Prerequisites

1. Install dependencies:
```bash
cd /projects/project-manager-mcp
npm install
```

2. Build the project:
```bash
npm run build
```

## Test Commands

Once configured in Claude Desktop, you can test with these commands:

### 1. Create a PRD
```
Use the create_prd tool with:
- title: "User Authentication System"
- description: "Implement secure user authentication with OAuth2 support"
- owner: "john_doe"
```

### 2. Create Epics
```
Use the create_epics tool with:
- epics: [
    {
      "prd_id": "<PRD_ID_FROM_STEP_1>",
      "title": "OAuth2 Integration",
      "description": "Implement OAuth2 for Google and GitHub",
      "priority": "high"
    },
    {
      "prd_id": "<PRD_ID_FROM_STEP_1>",
      "title": "User Profile Management",
      "description": "Create user profile CRUD operations",
      "priority": "medium"
    }
  ]
```

### 3. Create Tasks
```
Use the create_tasks tool with:
- tasks: [
    {
      "epic_id": "<EPIC_ID_FROM_STEP_2>",
      "title": "Setup OAuth2 providers",
      "description": "Configure Google and GitHub OAuth applications",
      "priority": "high",
      "assignee": "jane_smith"
    }
  ]
```

### 4. Update Task Progress
```
Use the update_task tool with:
- id: "<TASK_ID_FROM_STEP_3>"
- status: "in_progress"
```

### 5. Add Notes
```
Use the add_task_notes tool with:
- task_id: "<TASK_ID_FROM_STEP_3>"
- notes: ["Created OAuth apps", "Waiting for approval from security team"]
```

### 6. Query Tasks
```
Use get_tasks_by_assignee with:
- assignee: "jane_smith"
```

## Verification

The data is stored in `tasks.json` (or the path specified in TASK_FILE_PATH).
You can view the raw data:

```bash
cat tasks.json | jq .
```
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "."
  },
  "include": [
    "./**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

</files>
